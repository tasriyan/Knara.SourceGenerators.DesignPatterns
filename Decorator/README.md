# Decorator Factory Generator
[![Build and Test](https://github.com/tasriyan/Knara.SourceGenerators.DesignPatterns/actions/workflows/build.yml/badge.svg)](https://github.com/tasriyan/Knara.SourceGenerators.DesignPatterns/actions/workflows/build.yml)
[![Publish NuGet Packages](https://github.com/tasriyan/Knara.SourceGenerators.DesignPatterns/actions/workflows/publish.yml/badge.svg)](https://github.com/tasriyan/Knara.SourceGenerators.DesignPatterns/actions/workflows/publish.yml)
[![NuGet](https://img.shields.io/nuget/v/Knara.SourceGenerators.DesignPatterns.Decorator.svg)](https://www.nuget.org/packages/Knara.SourceGenerators.DesignPatterns.Decorator/)
[![NuGet](https://img.shields.io/nuget/dt/Knara.SourceGenerators.DesignPatterns.Decorator.svg)](https://www.nuget.org/packages/Knara.SourceGenerators.DesignPatterns.Decorator/)
![.NET Standard 2.0](https://img.shields.io/badge/.NET_Standard-2.0-blue.svg?logo=dotnet&labelColor=512BD4)
[![Language](https://img.shields.io/badge/language-C%23-239120.svg)](https://docs.microsoft.com/en-us/dotnet/csharp/)

A C# source generator that automatically creates fluent factory methods for the Decorator design pattern.

## Features

- **Automatic Factory Generation**: Creates fluent factory classes for interfaces marked with `[GenerateDecoratorFactory]`
- **Type-Safe Decorator Chaining**: Compile-time safety with IntelliSense support
- **Flexible Constructor Injection**: Supports decorators with varying constructor parameters
- **Clean Fluent API**: Method chaining for readable decorator composition

## Quick Start
Add the source generator to your project:
```bash
<ItemGroup> <ProjectReference Include="path/to/Knara.SourceGenerators.DesignPatterns.Decorator.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false" /> </ItemGroup>
```

Or via NuGet (when published):
```bash
dotnet add package Knara.SourceGenerators.DesignPatterns.Decorator
```
If you are using the generator in .net 4.+ projects, refer to [this guide](../dotnet-legacy-guide.md) for additional steps.

### 1. Mark Your Interface

Add the `[GenerateDecoratorFactory]` attribute to your service interface:
```csharp
[GenerateDecoratorFactory(BaseName = "User")] 
public interface IUserService 
{ 
	Task<User> GetUserByIdAsync(int userId); 
	Task<List<User>> GetAllUsersAsync(); 
	Task CreateUserAsync(User user); 
	Task UpdateUserAsync(User user); 
	Task DeleteUserAsync(int userId);
}
```

### 2. Create Your Base Implementation
```csharp
public class UserService : IUserService 
{ 
	public async Task<User> GetUserByIdAsync(int userId) 
	{ 
	// Simulate database call await Task.Delay(100); 
	return new User { Id = userId, Email = "user@example.com" }; 
	}
	// ... other methods
}
```

### 3. Create Decorators

Each decorator should implement the interface and be marked with `[Decorator]`:
```csharp
[Decorator(Type = "Logging")] 
public class UserLoggingDecorator : IUserService 
{
	private readonly IUserService _inner;
	private readonly ILogger<IUserService> _logger;
	public UserLoggingDecorator(IUserService inner, ILogger<IUserService> logger)
	{
		_inner = inner;
		_logger = logger;
	}

	public async Task<User> GetUserByIdAsync(int userId)
	{
		_logger.LogInformation($"Getting user by ID: {userId}");
		var user = await _inner.GetUserByIdAsync(userId);
		_logger.LogInformation($"Retrieved user: {user.Email}");
		return user;
	}

	// ... other methods
}
```

### 4. Use the Generated Factory
```csharp
// Create decorated service using the generated factory 
IUserService userService = UserDecoratorFactory 
	.Create(new UserService())
	.WithValidation() 
	.WithCaching(cache) 
	.WithLogging(logger);
// Use the service normally 
var user = await userService.GetUserByIdAsync(1);
```

## Generated Factory Code

For the `IUserService` interface, the generator creates:
```csharp
// <auto-generated /> #nullable enable
namespace Demo.Decorator.ConsoleApp;
public static class UserDecoratorFactory 
{ 
	public static IUserService Create(IUserService implementation) 
	{ 
		return implementation; 
	}
	public static IUserService WithLogging(this IUserService service, ILogger<IUserService> logger)
	{
		return new UserLoggingDecorator(service, logger);
	}

	public static IUserService WithCaching(this IUserService service, IMemoryCache cache)
	{
		return new UserCachingDecorator(service, cache);
	}

	public static IUserService WithValidation(this IUserService service)
	{
		return new UserValidationDecorator(service);
	}

	public static IUserService WithPerformanceMonitoring(this IUserService service, ILogger<UserPerformanceMonitoringDecorator> logger)
	{
		return new UserPerformanceMonitoringDecorator(service, logger);
	}
}
```

### Dependency Injection Integration
```csharp
	public static IServiceCollection DependencyInjectionUsage(this IServiceCollection services)
	{
		services.AddScoped<IUserService>(provider =>
		{
			var implementation = new UserService();
			var logger = provider.GetRequiredService<ILogger<UserService>>();
			var performanceLogger = provider.GetRequiredService<ILogger<UserPerformanceMonitoringDecorator>>();
			var cache = provider.GetRequiredService<IMemoryCache>();

			return UserDecoratorFactory
				.Create(implementation)
				.WithValidation()
				.WithCaching(cache)
				.WithPerformanceMonitoring(performanceLogger)
				.WithLogging(logger);
		});
		
		return services;
	}
```
---