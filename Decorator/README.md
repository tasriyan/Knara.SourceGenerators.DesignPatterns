# Decorator Factory Generator

A C# source generator that automatically creates fluent factory methods for the Decorator design pattern.

## Features

- **Automatic Factory Generation**: Creates fluent factory classes for interfaces marked with `[GenerateDecoratorFactory]`
- **Type-Safe Decorator Chaining**: Compile-time safety with IntelliSense support
- **Flexible Constructor Injection**: Supports decorators with varying constructor parameters
- **Clean Fluent API**: Method chaining for readable decorator composition

Add the source generator to your project:
```bash
<ItemGroup> <ProjectReference Include="path/to/SourceGenerators.DesignPatterns.Decorator.csproj" OutputItemType="Analyzer" ReferenceOutputAssembly="false" /> </ItemGroup>
```

Or via NuGet (when published): 
```bash
dotnet add package SourceGenerators.DesignPatterns.Decorator
```


## Quick Start

### 1. Mark Your Interface

Add the `[GenerateDecoratorFactory]` attribute to your service interface:
```csharp
[GenerateDecoratorFactory(BaseName = "User")] 
public interface IUserService 
{ 
	Task<User> GetUserByIdAsync(int userId); 
	Task<List<User>> GetAllUsersAsync(); 
	Task CreateUserAsync(User user); 
	Task UpdateUserAsync(User user); 
	Task DeleteUserAsync(int userId);
}
```

### 2. Create Your Base Implementation
```csharp
public class UserService : IUserService 
{ 
	public async Task<User> GetUserByIdAsync(int userId) 
	{ 
	// Simulate database call await Task.Delay(100); 
	return new User { Id = userId, Email = "user@example.com" }; 
	}
	// ... other methods
}
```

### 3. Create Decorators

Each decorator should implement the interface and be marked with `[Decorator]`:
```csharp
[Decorator(Type = "Logging")] 
public class UserLoggingDecorator : IUserService 
{
	private readonly IUserService _inner;
	private readonly ILogger<IUserService> _logger;
	public UserLoggingDecorator(IUserService inner, ILogger<IUserService> logger)
	{
		_inner = inner;
		_logger = logger;
	}

	public async Task<User> GetUserByIdAsync(int userId)
	{
		_logger.LogInformation($"Getting user by ID: {userId}");
		var user = await _inner.GetUserByIdAsync(userId);
		_logger.LogInformation($"Retrieved user: {user.Email}");
		return user;
	}

	// ... other methods
}
```

### 4. Use the Generated Factory
```csharp
// Create decorated service using the generated factory 
IUserService userService = UserDecoratorFactory 
	.Create(new UserService())
	.WithValidation() 
	.WithCaching(cache) 
	.WithLogging(logger);
// Use the service normally 
var user = await userService.GetUserByIdAsync(1);
```

## Generated Factory Code

For the `IUserService` interface, the generator creates:
```csharp
// <auto-generated /> #nullable enable
namespace Demo.Decorator.ConsoleApp;
public static class UserDecoratorFactory 
{ 
	public static IUserService Create(IUserService implementation) 
	{ 
		return implementation; 
	}
	public static IUserService WithLogging(this IUserService service, ILogger<IUserService> logger)
	{
		return new UserLoggingDecorator(service, logger);
	}

	public static IUserService WithCaching(this IUserService service, IMemoryCache cache)
	{
		return new UserCachingDecorator(service, cache);
	}

	public static IUserService WithValidation(this IUserService service)
	{
		return new UserValidationDecorator(service);
	}

	public static IUserService WithPerformanceMonitoring(this IUserService service, ILogger<UserPerformanceMonitoringDecorator> logger)
	{
		return new UserPerformanceMonitoringDecorator(service, logger);
	}
}
```

### Dependency Injection Integration
```csharp
	public static IServiceCollection DependencyInjectionUsage(this IServiceCollection services)
	{
		services.AddScoped<IUserService>(provider =>
		{
			var implementation = new UserService();
			var logger = provider.GetRequiredService<ILogger<UserService>>();
			var performanceLogger = provider.GetRequiredService<ILogger<UserPerformanceMonitoringDecorator>>();
			var cache = provider.GetRequiredService<IMemoryCache>();

			return UserDecoratorFactory
				.Create(implementation)
				.WithValidation()
				.WithCaching(cache)
				.WithPerformanceMonitoring(performanceLogger)
				.WithLogging(logger);
		});
		
		return services;
	}
```

## Requirements

- .NET Standard 2.0 or higher
- C# 8.0 or higher (for source generators)
- Interface-based service design

## Troubleshooting

### Common Issues

1. **Factory not generated**
   - Ensure interface has `[GenerateDecoratorFactory]` attribute
   - Verify interface is public
   - Check for compilation errors

2. **Extension method not found**
   - Verify decorator class has `[Decorator(Type = "...")]` attribute
   - Ensure decorator implements the correct interface
   - Check constructor parameter order (interface first)

3. **Constructor parameters missing**
   - Verify constructor parameter types are accessible
   - Check parameter names match expected conventions
   - Ensure using statements are correct

### Debugging Tips

1. Enable source generator output to see generated code
2. Use IDE "Go to Definition" on factory methods
3. Check build output for source generator warnings
4. Verify attribute namespaces are correctly imported

## License

Apache License 2.0